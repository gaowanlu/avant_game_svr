<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
        }

        .controls button {
            width: 50px;
            height: 50px;
            margin: 5px;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 5px;
            font-size: 20px;
        }

        .actions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
        }

        .actions button {
            width: 50px;
            height: 50px;
            margin: 5px;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 5px;
            font-size: 20px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>

<body>
    <canvas id="scene" width="800" height="600"></canvas>
    <div class="controls">
        <button id="moveForward">↑</button>
        <button id="moveLeft">←</button>
        <button id="moveBackward">↓</button>
        <button id="moveRight">→</button>
    </div>
    <div class="actions">
        <button id="placeBlock">+</button>
        <button id="destroyBlock">-</button>
    </div>
    <script>
        class Item {
            constructor(id, x, y, z, width, height, depth) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.z = z;
                this.width = width;
                this.height = height;
                this.depth = depth;
            }
        }

        class Player {
            constructor(id, x, y, z, width, height, depth) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.z = z;
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.lastUpdate = Date.now();
            }

            onCollisionWithPlayer(other) {
                console.log(`Player ${this.id} collided with Player ${other.id}`);
            }

            onCollisionWithItem(item) {
                console.log(`Player ${this.id} collided with Item ${item.id}`);
            }
        }

        class GameMap {
            constructor(gridSize, width, height, depth) {
                this.gridSize = gridSize;
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.items = new Map();
            }

            isWithinBounds(x, y, z) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height && z >= 0 && z < this.depth;
            }

            addItem(item) {
                this.items.set(item.id, item);
            }

            removeItem(id) {
                this.items.delete(id);
            }

            checkCollision(x, y, z, width, height, depth, player) {
                for (let item of this.items.values()) {
                    if (x < item.x + item.width && x + width > item.x &&
                        y < item.y + item.height && y + height > item.y &&
                        z < item.z + item.depth && z + depth > item.z) {
                        player.onCollisionWithItem(item);
                        return true;
                    }
                }
                return false;
            }

            isPositionOccupied(x, y, z, width, height, depth) {
                for (let item of this.items.values()) {
                    if (x < item.x + item.width && x + width > item.x &&
                        y < item.y + item.height && y + height > item.y &&
                        z < item.z + item.depth && z + depth > item.z) {
                        return true;
                    }
                }
                return false;
            }
        }

        class GameServer {
            constructor(gridSize, width, height, depth) {
                this.map = new GameMap(gridSize, width, height, depth);
                this.players = new Map();
                this.plugins = [];
            }

            addPlayer(id) {
                let x, y, z;
                do {
                    x = Math.random() * 100;
                    y = 1; // 设置在地面之上
                    z = Math.random() * 100;
                } while (this.map.isPositionOccupied(x, y, z, 1, 1, 1));

                const player = new Player(id, x, y, z, 1, 1, 1);
                this.players.set(id, player);
            }

            removePlayer(id) {
                this.players.delete(id);
            }

            movePlayer(id, vx, vy, vz) {
                const player = this.players.get(id);
                if (player) {
                    player.vx = vx;
                    player.vy = vy;
                    player.vz = vz;
                }
            }

            update() {
                const now = Date.now();
                for (let player of this.players.values()) {
                    const duration = (now - player.lastUpdate) / 1000;
                    const newX = player.x + player.vx * duration;
                    const newY = player.y + player.vy * duration;
                    const newZ = player.z + player.vz * duration;
                    if (this.map.isWithinBounds(newX, newY, newZ) &&
                        !this.map.checkCollision(newX, newY, newZ, player.width, player.height, player.depth, player)) {
                        player.x = newX;
                        player.y = newY;
                        player.z = newZ;
                    }
                    player.lastUpdate = now;
                }
            }

            addItem(item) {
                this.map.addItem(item);
            }

            removeItem(id) {
                this.map.removeItem(id);
            }

            addPlugin(plugin) {
                this.plugins.push(plugin);
            }

            runPlugins() {
                for (let plugin of this.plugins) {
                    plugin(this);
                }
            }

            getPlayers() {
                return this.players;
            }

            getItems() {
                return this.map.items;
            }
        }

        function autoMovePlugin(server) {
            const lastDirectionChange = new Map();
            const now = Date.now();

            for (let player of server.getPlayers().values()) {
                if (!lastDirectionChange.has(player.id) || (now - lastDirectionChange.get(player.id)) > 5000) {
                    player.vx = Math.random() * 2 - 1;
                    player.vy = 0; // 保持在地面上
                    player.vz = Math.random() * 2 - 1;
                    lastDirectionChange.set(player.id, now);
                }
            }
        }

        function collisionAvoidancePlugin(server) {
            for (let player of server.getPlayers().values()) {
                for (let other of server.getPlayers().values()) {
                    if (player.id !== other.id &&
                        player.x < other.x + other.width && player.x + player.width > other.x &&
                        player.y < other.y + other.height && player.y + player.height > other.y &&
                        player.z < other.z + other.depth && player.z + player.depth > other.z) {
                        player.vx = -player.vx;
                        player.vy = -player.vy;
                        player.vz = -player.vz;
                    }
                }
            }
        }

        const canvas = document.getElementById('scene');
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // 天空颜色

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // 设置相机初始位置

        const controls = new THREE.PointerLockControls(camera, document.body);

        document.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            console.log('Pointer locked');
        });

        controls.addEventListener('unlock', () => {
            console.log('Pointer unlocked');
        });

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040); // 环境光
        scene.add(ambientLight);

        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, side: THREE.DoubleSide }); // 地面颜色
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const server = new GameServer(1, 100, 100, 100);
        server.addPlayer(1);
        server.addPlayer(2);
        server.addItem(new Item(1, 10, 1, 10, 2, 2, 2)); // 设置在地面之上
        server.addItem(new Item(2, 20, 1, 20, 3, 3, 3)); // 设置在地面之上
        server.addPlugin(autoMovePlugin);
        server.addPlugin(collisionAvoidancePlugin);

        const playerGeometry = new THREE.BoxGeometry(2, 2, 2); // 调整玩家大小
        const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
        const itemGeometry = new THREE.BoxGeometry(2, 2, 2);
        const itemMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });

        const playerMeshes = new Map();
        for (let player of server.getPlayers().values()) {
            const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            mesh.position.set(player.x, player.y, player.z);
            scene.add(mesh);
            playerMeshes.set(player.id, mesh);
        }

        const itemMeshes = new Map();
        for (let item of server.getItems().values()) {
            const mesh = new THREE.Mesh(itemGeometry, itemMaterial);
            mesh.position.set(item.x, item.y, item.z);
            scene.add(mesh);
            itemMeshes.set(item.id, mesh);
        }

        const moveSpeed = 0.1;
        const controlsState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };

        let lastSpacePress = 0;

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w':
                    controlsState.forward = true;
                    break;
                case 's':
                    controlsState.backward = true;
                    break;
                case 'a':
                    controlsState.left = true;
                    break;
                case 'd':
                    controlsState.right = true;
                    break;
                case ' ':
                    const now = Date.now();
                    if (now - lastSpacePress < 300) {
                        controlsState.down = true;
                    } else {
                        controlsState.up = true;
                    }
                    lastSpacePress = now;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'w':
                    controlsState.forward = false;
                    break;
                case 's':
                    controlsState.backward = false;
                    break;
                case 'a':
                    controlsState.left = false;
                    break;
                case 'd':
                    controlsState.right = false;
                    break;
                case ' ':
                    controlsState.up = false;
                    controlsState.down = false;
                    break;
            }
        });

        const previewGeometry = new THREE.BoxGeometry(2, 2, 2);
        const previewMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true });
        const previewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
        scene.add(previewMesh);

        function updatePreview() {
            const vector = new THREE.Vector3();
            vector.set((window.innerWidth / 2) / window.innerWidth * 2 - 1, -(window.innerHeight / 2) / window.innerHeight * 2 + 1, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = 5;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            previewMesh.position.set(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));
        }

        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // 左键放置方块
                const item = new Item(Date.now(), previewMesh.position.x, previewMesh.position.y, previewMesh.position.z, 2, 2, 2);
                server.addItem(item);
                const mesh = new THREE.Mesh(itemGeometry, itemMaterial);
                mesh.position.set(item.x, item.y, item.z);
                scene.add(mesh);
                itemMeshes.set(item.id, mesh);
            } else if (event.button === 2) { // 右键销毁方块
                const vector = new THREE.Vector3();
                vector.set((window.innerWidth / 2) / window.innerWidth * 2 - 1, -(window.innerHeight / 2) / window.innerHeight * 2 + 1, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const raycaster = new THREE.Raycaster(camera.position, dir);
                const intersects = raycaster.intersectObjects(Array.from(itemMeshes.values()));
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const mesh = intersect.object;
                    scene.remove(mesh);
                    itemMeshes.forEach((value, key) => {
                        if (value === mesh) {
                            server.removeItem(key);
                            itemMeshes.delete(key);
                        }
                    });
                }
            }
        });

        // 移动端按钮事件
        document.getElementById('moveForward').addEventListener('touchstart', () => controlsState.forward = true);
        document.getElementById('moveForward').addEventListener('touchend', () => controlsState.forward = false);
        document.getElementById('moveBackward').addEventListener('touchstart', () => controlsState.backward = true);
        document.getElementById('moveBackward').addEventListener('touchend', () => controlsState.backward = false);
        document.getElementById('moveLeft').addEventListener('touchstart', () => controlsState.left = true);
        document.getElementById('moveLeft').addEventListener('touchend', () => controlsState.left = false);
        document.getElementById('moveRight').addEventListener('touchstart', () => controlsState.right = true);
        document.getElementById('moveRight').addEventListener('touchend', () => controlsState.right = false);
        document.getElementById('placeBlock').addEventListener('touchstart', () => {
            const item = new Item(Date.now(), previewMesh.position.x, previewMesh.position.y, previewMesh.position.z, 2, 2, 2);
            server.addItem(item);
            const mesh = new THREE.Mesh(itemGeometry, itemMaterial);
            mesh.position.set(item.x, item.y, item.z);
            scene.add(mesh);
            itemMeshes.set(item.id, mesh);
        });
        document.getElementById('destroyBlock').addEventListener('touchstart', () => {
            const vector = new THREE.Vector3();
            vector.set((window.innerWidth / 2) / window.innerWidth * 2 - 1, -(window.innerHeight / 2) / window.innerHeight * 2 + 1, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const raycaster = new THREE.Raycaster(camera.position, dir);
            const intersects = raycaster.intersectObjects(Array.from(itemMeshes.values()));
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const mesh = intersect.object;
                scene.remove(mesh);
                itemMeshes.forEach((value, key) => {
                    if (value === mesh) {
                        server.removeItem(key);
                        itemMeshes.delete(key);
                    }
                });
            }
        });

        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (event.touches.length === 1) {
                const touchMoveX = event.touches[0].clientX;
                const touchMoveY = event.touches[0].clientY;
                const deltaX = touchMoveX - touchStartX;
                const deltaY = touchMoveY - touchStartY;
                const rotationSpeed = 0.005;
                camera.rotation.y -= deltaX * rotationSpeed;
                camera.rotation.x -= deltaY * rotationSpeed;
                touchStartX = touchMoveX;
                touchStartY = touchMoveY;
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            if (controlsState.forward) {
                controls.moveForward(moveSpeed);
            }
            if (controlsState.backward) {
                controls.moveForward(-moveSpeed);
            }
            if (controlsState.left) {
                controls.moveRight(-moveSpeed);
            }
            if (controlsState.right) {
                controls.moveRight(moveSpeed);
            }
            if (controlsState.up) {
                camera.position.y += moveSpeed;
            }
            if (controlsState.down) {
                camera.position.y = 2; // 落到地面上
            }

            updatePreview();

            server.runPlugins();
            server.update();

            for (let [id, player] of server.getPlayers()) {
                const mesh = playerMeshes.get(id);
                mesh.position.set(player.x, player.y, player.z);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>