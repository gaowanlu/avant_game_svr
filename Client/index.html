<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freeland</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: none;
        }

        #freeland-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            display: none;
        }

        #freeland-debug-text {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            display: none;
        }

        #freeland-debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            display: none;
        }

        #freeland-start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #freeland-in-game-ui {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            font-family: 'Minecraft Font', Arial, sans-serif;
            color: white;
            display: none;
        }

        .freeland-like-button {
            background: #555555;
            color: white;
            border: 2px solid #333333;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            text-align: center;
            text-transform: uppercase;
        }

        .freeland-like-button:hover {
            background: #777777;
        }

        select.freeland-like-select {
            background: #555555;
            color: white;
            border: 2px solid #333333;
            padding: 5px;
            font-size: 14px;
            font-family: 'Minecraft Font', Arial, sans-serif;
            margin-right: 10px;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>

<body>
    <!-- 开始界面 -->
    <div id="freeland-start-screen">
        <button id="freeland-start-button" class="freeland-like-button">GET START</button>
    </div>
    <!-- 调试输出面板 -->
    <div id="freeland-debug-text">Click to lock pointer</div>
    <div id="freeland-debug-panel"></div>

    <div id="freeland-crosshair">+</div>
    <div id="freeland-in-game-ui">
        <select id="freeland-block-type-select" class="freeland-like-select">
            <option value="TexturedDirt">TexturedDirt</option>
            <option value="TexturedGrass">TexturedGrass</option>
        </select>
        <button id="freeland-exit-button" class="freeland-like-button">Exit Game</button>
    </div>
</body>

<script>
    const freeland = {};

    window.addEventListener('DOMContentLoaded', () => freeland.OnDOMContentLoaded(), false);
    freeland.OnDOMContentLoaded = function () {
        console.log("DOMContentLoaded");

        // 显示调试面板
        this.GetDebugPanelElement().show();

        // 检查Three.js是否就绪
        if (!this.CheckExistsTHREE()) {
            // 直接结束
            return;
        }

        freeland.Game.init();
    }

    freeland.CheckExistsTHREE = function () {
        // Three.js可能加载失败了
        if (typeof THREE === "undefined") {
            console.error("THREE not exists");
            this.GetDebugPanelElement().update("Error: Three.js failed to load.");
            return false;
        } else {
            console.log("THREE exists");
            return true;
        }
    }

    freeland.GetDebugPanelElement = function () {
        const debugPanel = document.getElementById('freeland-debug-panel');
        return {
            el: debugPanel,
            show: function () {
                this.el.style.display = "block";
            },
            hide: function () {
                this.el.style.display = "none";
            },
            update: function (text) {
                this.el.innerHTML = text;
            }
        };
    }

    freeland.AssetManager = class {
        constructor() {
            this.textureLoader = new THREE.TextureLoader();
            this.materials = {};
            this.textures = {};
            // 用于记录管理的textures是否全部加载完毕
            this.texturesLoaded = false;

            this.textureNameMacro = {
                GRASS_TOP: 'GrassTop',
                GRASS_SIDE: 'GrassSide',
                DIRT: 'Dirt'
            };

            this.materialNameMacro = {
                GRASS_TERRAIN: 'GrassTerrain',
                DIRT_TERRAIN: 'DirtTerrain',
                TEXTURED_GRASS: 'TexturedGrass',
                TEXTURED_DIRT: 'TexturedDirt',
                OUTLINE: 'Outline',
                NPC: 'NPC'
            };
        }

        loadAssets(debugCallbackFunc) {
            return new Promise((resolve, reject) => {
                let loadedCount = 0;

                const resources = [
                    { name: this.textureNameMacro.GRASS_TOP, path: 'https://raw.githubusercontent.com/InventivetalentDev/minecraft-assets/1.21.1/assets/minecraft/textures/block/grass_block_top.png' },
                    { name: this.textureNameMacro.GRASS_SIDE, path: 'https://raw.githubusercontent.com/InventivetalentDev/minecraft-assets/1.21.1/assets/minecraft/textures/block/grass_block_side.png' },
                    { name: this.textureNameMacro.DIRT, path: 'https://raw.githubusercontent.com/InventivetalentDev/minecraft-assets/1.21.1/assets/minecraft/textures/block/dirt.png' }
                ];

                const onLoad = (textureName, texture) => {
                    debugCallbackFunc(`${textureName} texture loaded`);
                    loadedCount++;
                    if (loadedCount === resources.length) {
                        this.texturesLoaded = true;
                        // 当textxture加载完成后，开始初始化材质
                        this.initializeMaterials(debugCallbackFunc);
                        resolve();
                    }
                };

                const onError = (textureName, error) => {
                    debugCallbackFunc(`Error loading ${textureName} texture: ${err.message}`);
                    reject(err);
                };

                for (let resource of resources) {
                    this.textures[resource.name] = this.textureLoader.load(resource.path,
                        (texture) => onLoad(resource.name, texture),
                        undefined,
                        (err) => onError(resource.name, err)
                    )
                }

                Object.values(this.textures).forEach(texture => {
                    // 纹理放大过滤器 THREE.NearestFilter适合像素风
                    texture.magFilter = THREE.NearestFilter;
                    // 纹理缩小过滤器
                    texture.minFilter = THREE.NearestFilter;
                });
            });
        }

        initializeMaterials(debugCallbackFunc) {
            this.materials[this.materialNameMacro.GRASS_TERRAIN] = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            this.materials[this.materialNameMacro.DIRT_TERRAIN] = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            this.materials[this.materialNameMacro.TEXTURED_GRASS] = new THREE.MeshLambertMaterial({ map: this.textures[this.textureNameMacro.GRASS_SIDE] });
            this.materials[this.materialNameMacro.TEXTURED_DIRT] = new THREE.MeshLambertMaterial({ map: this.textures[this.textureNameMacro.DIRT] });
            this.materials[this.materialNameMacro.OUTLINE] = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            this.materials[this.materialNameMacro.NPC] = new THREE.LineBasicMaterial({ color: 0xff0000 });
        }

        getMaterial(type) {
            if (!this.materials[type]) {
                console.error("no such material: " + type);
            }
            return this.materials[type];
        }
    };

    freeland.Map = class {
        constructor(size) {
            this.size = size;
            this.blocks = {};
            this.scene = null;
        }

        // 初始化地图传入Three.js场景
        init(scene) {
            this.scene = scene;
        }

        // 加入块到地图
        setBlock(x, y, z, blockType, material) {
            const key = `${x},${y},${z}`;
            this.blocks[key] = new freeland.Block(x, y, z, blockType, material);
            // 将块加入到目标场景中
            this.blocks[key].addToScene(this.scene);
        };

        // 获取地图中的某个块
        getBlock(x, y, z) {
            return this.blocks[`${x},${y},${z}`] || null;
        }

        // 从地图中删除某个块
        removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if (this.blocks[key]) {
                // 从场景移除
                this.blocks[key].removeFromScene(this.scene);
                // 从地图移除
                delete this.blocks[key];
            }
        }

        // 初始化基础地面
        initTerrain(assetManager) {
            for (let x = 0; x < this.size; x++) {
                for (let z = 0; z < this.size; z++) {
                    this.setBlock(x, 0, z,
                        assetManager.materialNameMacro.TEXTURED_DIRT,
                        assetManager.getMaterial(assetManager.materialNameMacro.TEXTURED_DIRT));
                }
            }
        }

        // 清空地图所有块
        clearAllBlocks() {
            Object.keys(this.blocks).forEach(key => this.blocks[key].removeFromScene(this.scene));
            this.blocks = {};
        }
    };

    freeland.Block = class {
        constructor(x, y, z, type, material, isTerrain = false) {
            this.position = new THREE.Vector3(x, y, z);
            this.type = type;
            // 创建并初始化一个3D网格对象Mesh表示场景中的一个立方体方块
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
            this.mesh.position.set(x, y, z);
            this.mesh.name = `${x},${y},${z}`;
            this.mesh.isBlock = true;
            // 非地形方块
            if (!isTerrain) {
                // 使该方块能够投射阴影到其他对象上
                this.mesh.castShadow = true;
                // 使该方块能够接收其他对象投射的阴影
                this.mesh.receiveShadow = true;
            }
        }

        addToScene(scene) {
            scene.add(this.mesh);
        }

        removeFromScene(scene) {
            scene.remove(this.mesh);
        }
    };

    // Base class for game entities
    freeland.Actor = class {
        constructor(x, y, z) {
            this.position = new THREE.Vector3(x, y, z);
            this.velocity = new THREE.Vector3(0, 0, 0);
        }

        // 由派生类实现
        update(map, worldSize) {
        }
    };

    // 玩家
    freeland.Player = class extends freeland.Actor {
        constructor(x, y, z, camera) {
            super(x, y, z);
            // Three.js相机
            this.camera = camera;
            // 定义玩家碰撞体高度，模拟人类身高
            this.height = 1.8;
            // 定义玩家碰撞体宽度，模拟人类宽度
            this.width = 0.4;
            // 移动速度
            this.speed = 0.0717;
            // 跳跃力度
            this.jumpStrength = 0.2;
            // 重力
            this.gravity = -0.01;
            // 目标旋转
            this.targetRotation = { x: 0, y: 0 };
            // 当前旋转
            this.currentRotation = { x: 0, y: 0 };
            // 旋转平滑因子
            this.rotationSmoothing = 0.1;
            // 相机位置
            this.camera.position.copy(this.position);
        }

        // true: 目标位置没有障碍物，玩家头可以移动到该位置
        // false: 目标位置有方块(脚部或头部位置被占用)，玩家头无法移动
        canMoveTo(x, y, z, map) {
            // 如果玩家到了指定位置 身体部分有方块
            // 则玩家根本不能放在目标位置
            // 脚
            const feet = Math.floor(y - this.height);
            // 头
            const head = Math.floor(y);
            const checkX = Math.floor(x);
            const checkZ = Math.floor(z);

            // 检测脚部位方块
            // y-this.height+0.1 能保证 feet时正的
            const feetBlock = y > this.height + 0.1 ? map.getBlock(checkX, feet, checkZ) : null;
            // 检测头部位置方块
            const headBlock = map.getBlock(checkX, head, checkZ);
            if (feetBlock || headBlock) {
                return false;
            }
            return true;
        }

        updateRotation(event, debugCallbackFunc) {
            // 根据鼠标水平移动更新玩家的偏航角yaw 绕Y轴的旋转
            // 灵敏度因子0.001，将像素移动转换为角度（弧度）。例如，移动1000像素对应1弧度（约57.3°）
            this.targetRotation.y -= event.movementX * 0.001;
            // 根据鼠标垂直移动更新玩家的俯仰角（pitch，绕X轴的旋转）。
            this.targetRotation.x -= event.movementY * 0.001;
            // 限制俯仰角（targetRotation.x）在 ±90°（±π/2 弧度）范围内。
            this.targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetRotation.x));
            // 将俯仰角从弧度转换为度，并保留1位小数。
            const pitchDeg = (this.targetRotation.x * 180 / Math.PI).toFixed(1);
            // 将偏航角从弧度转换为度，并保留1位小数。
            const yawDeg = (this.targetRotation.y * 180 / Math.PI).toFixed(1);
            if (debugCallbackFunc) {
                debugCallbackFunc(`Camera rotation: pitch=${pitchDeg}°, yaw=${yawDeg}°`);
            }
        }

        // 定义 Player 类的 update 方法，负责每帧更新玩家的状态
        // 参数：map（游戏世界地图，用于碰撞检测），keys（键盘输入状态），debugCallbackFunc（调试回调函数）
        update(map, keys, debugCallbackFunc) {
            // 应用重力：将重力加速度（this.gravity，通常为负值）累加到玩家的垂直速度（velocity.y）
            this.velocity.y += this.gravity;

            // 更新位置：将玩家的速度向量（this.velocity）应用到当前位置（this.position）
            // Three.js 的 Vector3.add 方法会将速度分量加到位置分量上，实现移动
            this.position.add(this.velocity);

            // 检测地面碰撞：检查玩家是否低于最低高度（this.height，通常为玩家身高）
            if (this.position.y < this.height) {
                // 如果玩家低于地面（y < this.height），将玩家位置固定到地面（y = this.height）
                this.position.y = this.height;
                // 重置垂直速度为 0，模拟落地效果，防止继续下落
                this.velocity.y = 0;
            }

            // 定义移动方向向量：创建一个 Three.js 的 Vector3 对象，用于存储玩家的水平移动方向
            const direction = new THREE.Vector3();

            // 检测 W 键（前移）：如果按下 W 键，方向向量 z 分量减 1（向前移动）
            if (keys['KeyW']) direction.z -= 1;

            // 检测 S 键（后移）：如果按下 S 键，方向向量 z 分量加 1（向后移动）
            if (keys['KeyS']) direction.z += 1;

            // 检测 A 键（左移）：如果按下 A 键，方向向量 x 分量减 1（向左移动）
            if (keys['KeyA']) direction.x -= 1;

            // 检测 D 键（右移）：如果按下 D 键，方向向量 x 分量加 1（向右移动）
            if (keys['KeyD']) direction.x += 1;

            // 检测跳跃（空格键）：仅当玩家在地面上（y <= this.height）时允许跳跃
            if (keys['Space'] && this.position.y <= this.height) this.velocity.y = this.jumpStrength;

            // 检查是否需要移动：如果方向向量长度大于 0（即有键盘输入）
            if (direction.length() > 0) {
                // 归一化方向向量：将方向向量长度设为 1，保持移动速度一致（无论按单键还是组合键）
                direction.normalize(); // 归一化后就是方向了

                // 应用玩家朝向：将方向向量绕 Y 轴旋转，基于当前视角的偏航角（currentRotation.y）
                // 确保移动方向与玩家视角一致（例如按 W 键时向前方移动）
                const move = direction.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), this.currentRotation.y);

                // 限制移动到水平面：将移动向量的 y 分量设为 0，仅允许水平移动
                move.y = 0;

                // 应用移动速度：将移动向量乘以玩家速度（this.speed），得到每帧的位移
                move.multiplyScalar(this.speed); // 方向乘速度得出位移

                // 计算新位置：将移动向量加到当前位置，得到目标位置
                const newPos = this.position.clone().add(move);

                // 碰撞检测：调用 canMoveTo 方法检查目标位置是否可达（无障碍物）
                if (this.canMoveTo(newPos.x, this.position.y, newPos.z, map)) {
                    // 如果可移动：更新玩家的 x 和 z 坐标到新位置
                    this.position.x = newPos.x;
                    this.position.z = newPos.z;
                    // 输出调试信息：记录允许移动到的位置，保留两位小数
                    debugCallbackFunc(`Move allowed to: x=${newPos.x.toFixed(2)}, y=${newPos.y.toFixed(2)}, z=${newPos.z.toFixed(2)}`);
                } else {
                    // 如果有碰撞：输出碰撞位置的格子坐标（脚部格子），用于调试
                    debugCallbackFunc(`Collision at: x=${Math.floor(newPos.x)}, y=${Math.floor(newPos.y - this.height)}, z=${Math.floor(newPos.z)}`);
                }
            }

            // 平滑更新俯仰角：通过插值使当前俯仰角（currentRotation.x）逐渐接近目标俯仰角（targetRotation.x）
            // 使用 rotationSmoothing（例如 0.1）控制平滑速度
            this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * this.rotationSmoothing;

            // 平滑更新偏航角：通过插值使当前偏航角（currentRotation.y）逐渐接近目标偏航角（targetRotation.y）
            this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * this.rotationSmoothing;

            // 更新相机旋转：将当前旋转角度应用到相机（俯仰角 x，偏航角 y，滚转角 z 设为 0）
            this.camera.rotation.set(this.currentRotation.x, this.currentRotation.y, 0);

            // 更新相机位置：将玩家位置复制到相机，确保相机与玩家同步（通常表示第一人称视角）
            this.camera.position.copy(this.position);
        }
    };

    // 定义 NPC 类，继承自 freeland.Actor，用于表示游戏中的非玩家角色
    freeland.NPC = class extends freeland.Actor {
        // 构造函数：初始化 NPC 的位置、可视化模型、速度和移动计时器
        // 参数：x, z（水平坐标），scene（Three.js 场景），material（线条材质）
        constructor(x, z, scene, material) {
            // 调用父类 Actor 的构造函数，设置 NPC 初始位置为 (x, 1, z)
            // y=1 表示 NPC 固定在地面（y=1 的高度）
            super(x, 1, z);

            // 创建一个 Three.js Group 对象，用于组织 NPC 的可视化模型
            this.group = new THREE.Group();

            // 为 Group 设置唯一名称，格式为 "npc_x_z"，便于调试和查找
            this.group.name = `npc_${x}_${z}`;

            // 定义 NPC 的几何形状：使用线段（LineSegments）表示一个简单的 3D 模型
            // points 数组定义了线段的顶点，形成一个类似立方体或框架的形状
            const points = [
                new THREE.Vector3(0, 0.5, 0), new THREE.Vector3(0, 1.5, 0), // 中心垂直线（底部到顶部）
                new THREE.Vector3(-0.1, 1.5, -0.1), new THREE.Vector3(0.1, 1.5, -0.1), // 顶部矩形边
                new THREE.Vector3(0.1, 1.5, -0.1), new THREE.Vector3(0.1, 1.5, 0.1), // 顶部矩形边
                new THREE.Vector3(0.1, 1.5, 0.1), new THREE.Vector3(-0.1, 1.5, 0.1), // 顶部矩形边
                new THREE.Vector3(-0.1, 1.5, 0.1), new THREE.Vector3(-0.1, 1.5, -0.1), // 顶部矩形边
                new THREE.Vector3(-0.1, 1.2, 0), new THREE.Vector3(0.1, 1.2, 0), // 中间水平线
                new THREE.Vector3(-0.1, 0.5, 0), new THREE.Vector3(-0.1, 0, 0), // 左侧垂直线
                new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.1, 0, 0) // 右侧垂直线
            ];

            // 创建 BufferGeometry，从 points 数组生成线段的几何体
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // 创建 LineSegments 对象，使用传入的材质（material）渲染线段
            const line = new THREE.LineSegments(geometry, material);

            // 将线段模型添加到 Group 中，组成 NPC 的可视化表示
            this.group.add(line);

            // 设置 Group 的位置为 (x, 1, z)，与 NPC 位置同步
            this.group.position.set(x, 1, z);

            // 将 Group 添加到 Three.js 场景中，使 NPC 模型可见
            scene.add(this.group);

            // 初始化速度向量为 (0, 0, 0)，表示 NPC 初始静止
            this.velocity = new THREE.Vector3(0, 0, 0);

            // 初始化移动计时器，随机值为 1 到 3 秒，用于控制 NPC 移动 Ascent 随机移动
            this.moveTimer = Math.random() * 2 + 1;

            // 设置 NPC 移动速度为 0.05 单位每帧
            this.speed = 0.05;
        }

        // 方法：检查 NPC 是否可以移动到指定位置 (x, z)
        // 参数：x, z（目标坐标），map（游戏世界地图），worldSize（世界边界大小）
        canMoveTo(x, z, map, worldSize) {
            // 将目标坐标取整，转换为格子坐标（游戏世界以整数格子划分）
            const checkX = Math.floor(x);
            const checkZ = Math.floor(z);

            // 检查目标位置 (checkX, 1, checkZ) 是否有方块
            // y=1 表示检查地面高度的方块
            const block = map.getBlock(checkX, 1, checkZ);

            // 检查是否超出世界边界或有方块阻挡
            // x, z 的范围限制在 [0.1, worldSize - 0.1]，避免 NPC 移出世界
            if (x < 0.1 || x >= worldSize - 0.1 || z < 0.1 || z >= worldSize - 0.1 || block) {
                // 如果超出边界或有方块，返回 false（不可移动）
                return false;
            }

            // 否则返回 true（可移动）
            return true;
        }

        // 方法：更新 NPC 的状态（每帧调用）
        // 参数：map（地图），worldSize（世界大小），debugCallback（调试回调函数）
        update(map, worldSize, debugCallback) {
            // 减少移动计时器（假设游戏以 60 帧/秒运行，1/60 秒每帧）
            this.moveTimer -= 1 / 60;

            // 当计时器小于等于 0 时，随机生成新的移动速度
            if (this.moveTimer <= 0) {
                // 随机速度：x 和 z 分量在 [-speed, speed] 范围内，y 分量为 0（NPC 仅在地面移动）
                this.velocity.set(
                    (Math.random() - 0.5) * 2 * this.speed, // 随机 x 速度（-0.05 到 0.05）
                    0, // y 速度固定为 0
                    (Math.random() - 0.5) * 2 * this.speed // 随机 z 速度（-0.05 到 0.05）
                );
                // 重置计时器为随机值（1 到 3 秒），控制下次速度更新的时间
                this.moveTimer = Math.random() * 2 + 1;
            }

            // 计算新位置：当前位置加上速度向量
            const newPos = this.position.clone().add(this.velocity);

            // 检查是否可以移动到新位置
            if (this.canMoveTo(newPos.x, newPos.z, map, worldSize)) {
                // 如果可移动，更新 NPC 的 x 和 z 坐标
                this.position.x = newPos.x;
                this.position.z = newPos.z;

                // 限制 NPC 位置在世界边界内（[0.1, worldSize - 0.1]）
                this.position.x = Math.max(0.1, Math.min(worldSize - 0.1, this.position.x));
                this.position.z = Math.max(0.1, Math.min(worldSize - 0.1, this.position.z));

                // 更新 Group 的位置，与 NPC 位置同步
                this.group.position.set(this.position.x, 1, this.position.z);

                // 输出调试信息：记录 NPC 移动到的位置，保留两位小数
                debugCallback(`NPC moved to: x=${this.position.x.toFixed(2)}, y=1, z=${this.position.z.toFixed(2)}`);
            }
        }

        // 方法：从场景中移除 NPC
        // 参数：scene（Three.js 场景）
        remove(scene) {
            // 从场景中移除 NPC 的 Group 对象，删除其可视化模型
            scene.remove(this.group);
        }
    };

    // 定义 Control 类，负责处理玩家输入、交互和方块高亮
    freeland.Control = class {
        // 初始化控制相关的属性和事件监听器
        // 参数：Game（游戏主对象），player（玩家对象），map（地图对象），scene（Three.js 场景），assetManager（资源管理器）
        constructor(Game, player, map, scene, assetManager) {
            // 保存游戏主对象，用于访问游戏状态和调试方法
            this.Game = Game;
            // 保存玩家对象，用于更新玩家旋转和位置
            this.player = player;
            // 保存地图对象，用于方块的查询、添加和移除
            this.map = map;
            // 保存 Three.js 场景，用于添加/移除高亮模型
            this.scene = scene;
            // 保存资源管理器，用于获取方块材质
            this.assetManager = assetManager;
            // 初始化键盘输入状态对象，记录按下的键（键码: true/false）
            this.keys = {};
            // 创建 Three.js Raycaster 对象，用于射线检测（检测玩家视角与方块的交点）
            this.raycaster = new THREE.Raycaster();
            // 设置射线检测的最大距离为 5 个单位
            this.raycaster.far = 5;
            // 初始化鼠标位置为 (0, 0)，用于射线检测（屏幕坐标，范围 [-1, 1]）
            this.mouse = new THREE.Vector2(0, 0);
            // 初始化当前高亮模型为 null（用于方块高亮效果）
            this.currentOutline = null;
            // 初始化破坏状态为 false，表示当前未在破坏方块
            this.isBreaking = false;
            // 设置默认选择的方块类型为 'dirt'（泥土）
            this.selectedBlockType = this.assetManager.materialNameMacro.TEXTURED_GRASS;
            // 设置事件监听器，处理键盘、鼠标等输入
            this.setupEventListeners();
        }

        // 方法：设置当前选择的方块类型
        // 参数：type（方块类型字符串，如 'dirt'）
        setBlockType(type) {
            this.selectedBlockType = type;
            this.Game.debug(`Block type changed to: ${type}`);
        }

        // 方法：设置事件监听器，处理键盘、鼠标输入和指针锁定
        setupEventListeners() {
            // 监听键盘按下事件
            document.addEventListener('keydown', (e) => {
                // 如果游戏未运行，忽略事件
                if (!this.Game.isRunning) return;
                // 记录按下的键（键码设为 true）
                this.keys[e.code] = true;
                // 输出调试信息，记录按下的键码
                this.Game.debug(`Key pressed: ${e.code}`);
            });

            // 监听键盘释放事件
            document.addEventListener('keyup', (e) => {
                // 如果游戏未运行，忽略事件
                if (!this.Game.isRunning) return;
                // 记录释放的键（键码设为 false）
                this.keys[e.code] = false;
            });

            // 监听鼠标右键（上下文菜单）事件
            document.addEventListener('contextmenu', (e) => {
                // 如果游戏运行，阻止默认右键菜单（避免干扰游戏操作）
                if (this.Game.isRunning) e.preventDefault();
            });

            // 监听鼠标按下事件（左键或右键）
            document.addEventListener('mousedown', (e) => {
                // 如果游戏未运行或正在破坏方块，忽略事件
                if (!this.Game.isRunning || this.isBreaking) return;
                // 设置射线起点为玩家相机，方向为鼠标位置（屏幕中心）
                this.raycaster.setFromCamera(this.mouse, this.player.camera);
                // 获取所有方块的网格对象，执行射线检测
                const intersects = this.raycaster.intersectObjects(Object.values(this.map.blocks).map(b => b.mesh));
                // 如果射线击中方块
                if (intersects.length > 0) {
                    // 获取第一个交点（最近的方块）
                    const intersect = intersects[0];
                    // 获取被击中方块的位置
                    const pos = intersect.object.position;
                    // 输出调试信息，记录击中的方块位置
                    this.Game.debug(`Raycast hit block at: x=${pos.x}, y=${pos.y}, z=${pos.z}`);
                    // 左键点击（button === 0）：破坏方块
                    if (e.button === 0) {
                        // 设置破坏状态为 true，防止重复触发
                        this.isBreaking = true;
                        // 延迟 300ms 后移除方块，模拟破坏动画
                        setTimeout(() => {
                            // 移除地图中指定位置的方块（取整坐标）
                            this.map.removeBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));
                            // 重置破坏状态
                            this.isBreaking = false;
                        }, 300);
                        // 右键点击（button === 2）：放置方块
                    } else if (e.button === 2) {
                        // 获取交点所在面的法向量（指向外部）
                        const normal = intersect.face.normal;
                        // 计算新方块位置：击中位置 + 法向量（放置在击中面旁）
                        const newPos = pos.clone().add(normal);
                        // 取整新位置坐标
                        const x = Math.floor(newPos.x);
                        const y = Math.floor(newPos.y);
                        const z = Math.floor(newPos.z);
                        // 检查目标位置是否为空（无方块）
                        if (!this.map.getBlock(x, y, z)) {
                            // 在目标位置放置新方块，使用当前选择的方块类型和对应材质
                            this.map.setBlock(x, y, z, this.selectedBlockType, this.assetManager.getMaterial(this.selectedBlockType));
                            // 输出调试信息，记录放置的方块类型和位置
                            this.Game.debug(`Placed block (${this.selectedBlockType}) at: x=${x}, y=${y}, z=${z}`);
                        }
                    }
                } else {
                    // 如果未击中方块，输出调试信息
                    this.Game.debug('No block hit by raycaster');
                }
            });

            // 监听鼠标点击事件（用于请求指针锁定）
            document.addEventListener('click', (e) => {
                // 如果游戏未运行或点击目标不是渲染器画布，忽略事件
                if (!this.Game.isRunning || e.target !== this.Game.renderer.domElement) return;
                // 请求指针锁定，锁定鼠标以支持第一人称视角控制
                this.Game.renderer.domElement.requestPointerLock();
            });

            // 监听指针锁定状态变化
            document.addEventListener('pointerlockchange', () => {
                // 如果游戏未运行，忽略事件
                if (!this.Game.isRunning) return;
                // 检查指针是否锁定在渲染器画布上
                // 更新 UI 调试文本，提示玩家当前状态
                this.Game.ui.setDebugText(document.pointerLockElement === this.Game.renderer.domElement
                    ? 'Pointer locked - Use WASD to move'
                    : 'Click to lock pointer');
            });

            // 监听鼠标移动事件
            document.addEventListener('mousemove', (e) => {
                // 如果游戏未运行或指针未锁定，忽略事件
                if (!this.Game.isRunning || document.pointerLockElement !== this.Game.renderer.domElement) return;
                // 调用玩家对象的 updateRotation 方法，更新视角旋转（俯仰和偏航）
                this.player.updateRotation(e, this.Game.debug.bind(this.Game));
            });
        }

        // 方法：更新方块高亮效果
        updateBlockHighlight() {
            // 如果当前有高亮模型，先从场景中移除
            if (this.currentOutline) {
                this.scene.remove(this.currentOutline);
                this.currentOutline = null;
            }
            // 设置射线起点为玩家相机，方向为鼠标位置（屏幕中心）
            this.raycaster.setFromCamera(this.mouse, this.player.camera);
            // 获取所有方块的网格对象，执行射线检测
            const intersects = this.raycaster.intersectObjects(Object.values(this.map.blocks).map(b => b.mesh));
            // 如果射线击中方块
            if (intersects.length > 0) {
                // 获取击中方块的位置
                const pos = intersects[0].object.position;
                // 创建高亮方块的几何体（略大于 1x1x1，以包裹目标方块）
                const geometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
                // 创建高亮模型，使用资源管理器中的高亮材质
                this.currentOutline = new THREE.Mesh(geometry, this.assetManager.getMaterial(this.assetManager.materialNameMacro.OUTLINE));
                // 设置高亮模型位置，与目标方块对齐
                this.currentOutline.position.copy(pos);
                // 将高亮模型添加到场景中
                this.scene.add(this.currentOutline);
            }
        }
    };

    freeland.UI = class {
        constructor(Game) {
            this.Game = Game;
            this.startScreen = document.getElementById('freeland-start-screen');
            this.inGameUI = document.getElementById('freeland-in-game-ui');
            this.debugText = document.getElementById('freeland-debug-text');
            this.debugPanel = document.getElementById('freeland-debug-panel');
            this.crosshair = document.getElementById('freeland-crosshair');
            this.startButton = document.getElementById('freeland-start-button');
            this.exitButton = document.getElementById('freeland-exit-button');
            this.playBlockTypeSelect = document.getElementById('freeland-block-type-select');
            this.debugMessages = [];
        }

        init(startGameCallbackFunc, exitGameCallbackFunc) {
            this.startButton.addEventListener('click', startGameCallbackFunc);
            this.exitButton.addEventListener('click', exitGameCallbackFunc);
        }

        bindPlayBlockTypeSelectChange(playBlockTypeCallbackFunc) {
            this.playBlockTypeSelect.addEventListener('change', (e) => playBlockTypeCallbackFunc(e.target.value));
        }

        showStartScreen() {
            this.startScreen.style.display = 'flex';
            this.Game.renderer.domElement.style.display = 'none';
            this.crosshair.style.display = 'none';
            this.debugText.style.display = 'none';
            this.debugPanel.style.display = 'none';
            this.inGameUI.style.display = 'none';
        }

        showInGameUI() {
            this.startScreen.style.display = 'none';
            this.Game.renderer.domElement.style.display = 'block';
            this.crosshair.style.display = 'block';
            this.debugText.style.display = 'block';
            this.debugPanel.style.display = 'block';
            this.inGameUI.style.display = 'block';
        }

        setDebugText(text) {
            this.debugText.textContent = text;
        }

        updateDebugPanel(message) {
            this.debugMessages.push(message);
            if (this.debugMessages.length > 5) this.debugMessages.shift();
            let debugText = '';
            if (this.Game.player) {
                const pitchDeg = (this.Game.player.currentRotation.x * 180 / Math.PI).toFixed(1);
                const yawDeg = (this.Game.player.currentRotation.y * 180 / Math.PI).toFixed(1);
                debugText += `Player: x=${this.Game.player.position.x.toFixed(2)}, y=${this.Game.player.position.y.toFixed(2)}, z=${this.Game.player.position.z.toFixed(2)}\n`;
                debugText += `Camera: pitch=${pitchDeg}°, yaw=${yawDeg}°\n`;
            } else {
                debugText += `Player: Not initialized\nCamera: Not initialized\n`;
            }
            if (this.Game.npcs && this.Game.npcs.length > 0) {
                this.Game.npcs.forEach((npc, index) => {
                    debugText += `NPC ${index}: x=${npc.position.x.toFixed(2)}, z=${npc.position.z.toFixed(2)}\n`;
                });
            } else {
                debugText += `NPCs: None\n`;
            }
            debugText += '\nLogs:\n' + this.debugMessages.join('\n');
            this.debugPanel.innerHTML = debugText;
        }
    };

    freeland.Game = class {
        static isRunning = false;
        static scene = new THREE.Scene();
        static camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        static renderer = new THREE.WebGLRenderer();
        static player = null;
        static npcs = [];
        static map = null;
        static control = null;
        static ui = null;
        static assetManager = null;
        static pointLight = null;
        static animationFrameId = null;

        static debug(msg) {
            this.ui.updateDebugPanel(msg);
        }

        static init() {
            // UI初始化
            this.ui = new freeland.UI(this);
            this.ui.init(
                this.onStart.bind(this),
                this.onExit.bind(this)
            );
            // 初始化玩家
            this.player = new freeland.Player(8, 3.5, 8, this.camera);

            // 初始化地图
            this.map = new freeland.Map(16);

            // 初始化渲染器
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(this.renderer.domElement);

            // 场景中加入光照
            {
                const ambientLight = new THREE.AmbientLight(0x606060);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.set(1024, 1024);
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                this.scene.add(directionalLight);
                this.pointLight = new THREE.PointLight(0xffffff, 0.3, 10);
                this.scene.add(this.pointLight);
                this.debug('Lighting initialized: Ambient(0x606060), Directional(0xffffff, 0.8), Point(0xffffff, 0.3)');
            }

            // 资源管理器
            this.assetManager = new freeland.AssetManager();
            // 加载资源
            this.assetManager.loadAssets(this.debug.bind(this)).catch(err => {
                this.debug(`Failed to load assets: ${err.message}`);
            });

            // 将场景绑定到地图对象
            this.map.init(this.scene);

            // 交互控制器
            this.control = new freeland.Control(this, this.player, this.map, this.scene, this.assetManager);
            this.ui.bindPlayBlockTypeSelectChange((e) => this.control.setBlockType(e.target.value));

            // 窗口大小改变
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 游戏开始直接显示开始界面
            this.ui.showStartScreen();
        };

        // 玩家点击UI 开始按钮回调
        static async onStart() {
            console.log("点击开始按钮");
            // 保证资源加载完毕
            if (this.assetManager.texturesLoaded) {
                this.debug('Waiting for textures to load...');
                try {
                    await this.assetManager.loadAssets(this.debug.bind(this));
                } catch (err) {
                    this.debug(`Failed to start game: ${err.message}`);
                    return;
                }
            }

            // 运行状态标记
            this.isRunning = true;
            // 显示局内UI
            this.ui.showInGameUI();
            // 初始化地面
            this.map.initTerrain(this.assetManager);

            // 初始化NPC
            this.npcs.length = 0;
            for (let i = 0; i < 3; i++) {
                const x = Math.floor(Math.random() * (this.map.size - 2)) + 1;
                const z = Math.floor(Math.random() * (this.map.size - 2)) + 1;
                const npc = new freeland.NPC(x, z, this.scene, this.assetManager.getMaterial(this.assetManager.materialNameMacro.NPC));
                this.npcs.push(npc);
                this.debug(`NPC ${this.npcs.length - 1} created at: x=${x}, y=1, z=${z}`);
            }

            // 初始化玩家
            this.player.position.set(8, 3.5, 8);
            this.player.targetRotation.x = 0;
            this.player.targetRotation.y = 0;
            this.player.currentRotation.x = 0;
            this.player.currentRotation.y = 0;
            this.camera.position.copy(this.player.position);
            this.pointLight.position.set(this.player.position.x, this.player.position.y + 0.5, this.player.position.z);

            this.debug('Game started');

            // 开始主循环
            this.mainLoop();
        }

        // 玩家点击UI 结束退出按钮回调
        static async onExit() {
            this.isRunning = false;
            cancelAnimationFrame(this.animationFrameId);
            this.ui.showStartScreen();
            this.map.clearAllBlocks();
            this.npcs.forEach(npc => npc.remove(this.scene));
            this.npcs.length = 0;
            this.player.position.set(8, 3.5, 8);
            this.player.velocity.set(0, 0, 0);
            this.debug('Game exited');
        }

        // 游戏主循环
        static async mainLoop() {
            if (!this.isRunning) return;
            this.animationFrameId = requestAnimationFrame(this.mainLoop.bind(this));

            this.player.update(this.map, this.control.keys, this.debug.bind(this));
            this.npcs.forEach((npc, index) => npc.update(this.map, this.map.size, msg => this.debug(`NPC ${index}: ${msg}`)));
            this.pointLight.position.set(this.player.position.x, this.player.position.y + 0.5, this.player.position.z);
            this.control.updateBlockHighlight();
            try {
                this.renderer.render(this.scene, this.camera);
            } catch (err) {
                this.debug(`Render error: ${err.message}`);
                console.error('Render error details:', err);
            }
        }

    };

</script>

</html>